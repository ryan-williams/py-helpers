
set_pythonstartup() {
  if [ -z "$PYTHONSTARTUP" ]; then
    local py_dir="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
    export PYTHONSTARTUP=$py_dir/startup.py
  fi
}
set_pythonstartup

# Source additional helpers
py_dir="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
[ -f "$py_dir/py-direnv-init.sh" ] && source "$py_dir/py-direnv-init.sh"
[ -f "$py_dir/.uv-rc" ] && source "$py_dir/.uv-rc"
[ -f "$py_dir/python-env-type.sh" ] && source "$py_dir/python-env-type.sh"

defn ve python -m virtualenv

virtualenv_activate() {
    python -m virtualenv "$1"
    . "$1/bin/activate"
}
defn vea virtualenv_activate

defn pidr pip install --dry-run
defn piu pip install --upgrade
defn piup pip install --upgrade pip
defn piuu pip install --user --upgrade
defn pii pip install
defn piii pip install --no-build-isolation
defn pif pip show
piie() {
    pip install -e "${@:-.}"
}
export -f piie

defn pis pip search
defn piun pip uninstall
defn piuny pip uninstall -y
defn piuy pip uninstall -y
defn pui pip uninstall
defn puy pip uninstall -y
pip_reinstall() {
  pip uninstall -y "$@"
  pip install "$@"
}
export -f pip_reinstall
defn piri pip_reinstall
defn puyi pip_reinstall

piui() {
  for arg in "$@"; do
    pip uninstall "$arg"
    pip install "$arg"
  done
}
export -f piui

pil() {
    if [ $# -eq 0 ]; then
        pip list
    else
      args=()
      for arg in "$@"; do
        args+=("-e" "$arg")
      done
      pip list | grep -i "${args[@]}"
    fi
}
export -f pil

pilc() {
    if [ $# -eq 0 ]; then
        pip list
    else
      pip list | grep "$@"
    fi
}
export -f pilc

pir() {
  if [ $# -eq 0 ]; then
    pip install -r requirements.txt
  else
    pip install -r "$@"
  fi
}
export -f pir

python_executable() {
  local exe=$(python -c 'import sys; print(sys.executable)')

  # Case 1: If it's through .venv/cur, resolve it to the actual version
  if [[ "$exe" == *"/.venv/cur/bin/python" ]]; then
    local base_dir="${exe%/.venv/cur/bin/python}"
    if [[ -L "$base_dir/.venv/cur" ]]; then
      local resolved=$(readlink "$base_dir/.venv/cur")
      exe="$base_dir/.venv/$resolved/bin/python"
    fi
  # Case 2: If it's .venv/bin/python (could be symlink to versioned dir)
  elif [[ "$exe" == *"/.venv/bin/python" ]]; then
    local base_dir="${exe%/.venv/bin/python}"
    # Check if .venv/bin is a symlink
    if [[ -L "$base_dir/.venv/bin" ]]; then
      local resolved=$(readlink "$base_dir/.venv/bin")
      # resolved might be like "3.11.X/bin" or "../3.11.X/bin"
      resolved="${resolved%/bin}"  # Remove /bin suffix
      exe="$base_dir/.venv/$resolved/bin/python"
    fi
  fi

  echo "$exe"
}
export -f python_executable
defn pex python_executable
defn pyx python_executable
defn ppe python_executable


python_executable_copy() {
  if ! which copy &>/dev/null && ! declare -F copy &>/dev/null; then
    echo '`copy` command not found' >&2
    return 1
  fi
  python_executable | head -c -1 | tee >(copy)
}
export -f python_executable_copy
defn pxy python_executable_copy

defn pyi python -i

alias apy="alias-which python"
all_python_versions() {
  alias-which python && \
  python --version && \
  python_executable
}
export -f all_python_versions
defn apv all_python_versions

export PYTHON_DEFAULT_VERSION=3.12.9
default_python_version() {
    echo "$PYTHON_DEFAULT_VERSION"
}
export -f default_python_version
defn dpv default_python_version
defn pdv default_python_version

defn pci python-check-import
defn ppp print-python-path
defn pmp python-module-path

defn py python-eval

alias pyv="python --version"

python_version() {
    python --version 2>&1 | grep -o '[0-9.]\+'
}
defn pyvq python_version

python_major_version() {
  python --version 2>&1 | grep -o '^Python [0-9]' | grep -o '[0-9]'
}
defn pymv python_major_version

epp() {
  echo "$PYTHONPATH"
}
export -f epp

# pyenv functionality removed - using uv for Python management

# pyenv install commands removed - use uv for Python management

# pyenv install function removed - use uv for Python management

# pyenv list/search commands removed - use uv for Python management
# Use 'uv python list' to see available Python versions

defn pss simple-server

defn ptlf pytest --lf
defn pylf pytest --lf

# pyenv uninstall commands removed - use uv for Python management

poetry_deps() {
    yq -r -ptoml -oj '.tool.poetry.dependencies | to_entries | [ .[] | select(.key != "python") ] | map([.key, .value] | join("==")) | join("\n")' pyproject.toml
}
export -f poetry_deps

poetry_dev_deps() {
    yq -r -ptoml -oj '.tool.poetry.dev-dependencies | to_entries | map([.key, .value] | join("==")) | join("\n")' pyproject.toml
}
export -f poetry_dev_deps

find_python_imports() {
    git grep -e '^from [^\.]*' -e '^import [^\.]*' \
    | sed 's/^[^:]\+://' \
    | awk '{ print $1,$2 }' \
    | awk -F. '{ print $1 }' \
    | awk '{ print $2 }' \
    | sort \
    | uniq
}
export -f find_python_imports
defn fpi find_python_imports

maybe_init_conda

defn pcr pre-commit run -a -v

alias pyt=pytest

defn mr memray run
defn mrn memray run --native
defn mrno memray run --native -o
defn mrnfo memray run --native -fo
defn mra memray run --native --follow-fork --trace-python-allocators -fo
defn mrano memray run --aggregate --native -o
defn mf memray flamegraph
defn mfg memray flamegraph
defn mfgo memray flamegraph -o
defn mfo memray flamegraph -o
defn ms memray stats
defn msj memray stats --json
defn msjo memray stats --json -o

defn phs python -m http.server

defn dsr datasette --reload --open

# Multi-version Python setup aliases (use with direnv)
alias spvm="py_direnv_init 3.11 3.12 3.13"  # Setup Python multi-version
alias pyvm="py_direnv_init 3.11 3.12 3.13"  # Alternative alias
